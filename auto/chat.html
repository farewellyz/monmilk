<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‡πÅ‡∏ä‡∏ó‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç ‚ù§Ô∏è</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Mitr:wght@300;400;500&display=swap" rel="stylesheet">

  <style>
    body {
      font-family: 'Mitr', sans-serif;
      background-color: #fce4ec;
      background-image: radial-gradient(#f8bbd0 1px, transparent 1px);
      background-size: 15px 15px;
    }
    /* Style for the chat messages container to hold the background image */
    #chat-messages {
      background-color: #ffffff; /* Default background for the chat area */
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      transition: background-image 0.3s ease-in-out; /* Smooth transition for background image */
      flex-1 p-4 overflow-y-auto space-y-4; /* Existing Tailwind classes */
    }
    #chat-messages::-webkit-scrollbar {
      width: 6px;
    }
    #chat-messages::-webkit-scrollbar-track {
      background: #f1f1f1;
    }
    #chat-messages::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 3px;
    }
    #chat-messages::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    /* Custom styles for voice message player */
    .voice-message-player {
      display: flex;
      align-items: center;
      gap: 8px; /* Space between play button and progress bar */
      background-color: #ffe0f0; /* Light pink background for the bubble */
      padding: 8px 12px;
      border-radius: 16px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }

    .voice-message-player button {
      background-color: #ff85a2; /* Pink button */
      color: white;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s;
    }

    .voice-message-player button:hover {
      background-color: #ff6e91;
    }

    .voice-message-player progress {
      flex-grow: 1; /* Make progress bar take available space */
      height: 8px;
      border-radius: 4px;
      background-color: #fce4ec; /* Background of the bar */
      border: none;
      -webkit-appearance: none; /* For Safari/Chrome */
      appearance: none;
    }

    /* Style for progress bar fill */
    .voice-message-player progress::-webkit-progress-bar {
      background-color: #fce4ec;
      border-radius: 4px;
    }
    .voice-message-player progress::-webkit-progress-value {
      background-color: #ff85a2; /* Pink fill color */
      border-radius: 4px;
    }
    .voice-message-player progress::-moz-progress-bar {
      background-color: #ff85a2;
      border-radius: 4px;
    }
    .voice-message-player .time-display {
      font-size: 0.75rem; /* text-xs */
      color: #718096; /* gray-600 */
      min-width: 40px; /* To prevent flickering when numbers change */
      text-align: right;
    }
  </style>
</head>
<body class="flex items-center justify-center min-h-screen bg-gray-100">

  <div class="w-full max-w-md h-[90vh] md:h-[80vh] flex flex-col bg-white rounded-2xl shadow-2xl overflow-hidden border-4 border-white">
    <header class="bg-pink-400 text-white p-4 flex items-center justify-between shadow-md">
      <h1 class="text-xl font-semibold"> ùë¥ùíö ùíçùíäùíç ùíÉùíêùíö ‚ô°</h1>
      <label for="upload-bg-input" class="cursor-pointer bg-pink-500 hover:bg-pink-600 text-white rounded-full p-2 w-10 h-10 flex items-center justify-center transition shadow-md hover:shadow-lg">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
          <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
        </svg>
        <input type="file" id="upload-bg-input" accept="image/*" class="hidden">
      </label>
    </header>

    <main id="chat-messages" class="flex-1 p-4 overflow-y-auto space-y-4">
      </main>

    <footer class="p-4 bg-white border-t border-gray-200">
      <div class="flex items-center space-x-2">
        <label for="upload-image-input" class="cursor-pointer bg-gray-200 hover:bg-gray-300 text-gray-700 rounded-full p-2 w-10 h-10 flex items-center justify-center transition shadow-sm hover:shadow-md">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
            <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008v-.008zm.008 0h.008v.008h-.008v-.008z" />
          </svg>
          <input type="file" id="upload-image-input" accept="image/*" class="hidden">
        </label>
        <input type="text" id="message-input" placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°..." class="flex-1 p-3 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-pink-400 transition">
        <button id="send-button" class="bg-pink-500 hover:bg-pink-600 text-white rounded-full p-3 w-12 h-12 flex items-center justify-center transition shadow-md hover:shadow-lg">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-send"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
        </button>
      </div>
    </footer>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const chatMessages = document.getElementById('chat-messages');
      const messageInput = document.getElementById('message-input');
      const sendButton = document.getElementById('send-button');
      const uploadBgInput = document.getElementById('upload-bg-input');
      const uploadImageInput = document.getElementById('upload-image-input');

      // Flags for controlling sound playback to prevent overlap using cooldown
      let isSendSoundOnCooldown = false;
      let isReceiveSoundOnCooldown = false;

      // New helper function to play sound
      function playSoundEffect(src, isSend) {
          // If already on cooldown for this type of sound, do nothing
          if ((isSend && isSendSoundOnCooldown) || (!isSend && isReceiveSoundOnCooldown)) {
              return;
          }

          // Set cooldown flag
          if (isSend) {
              isSendSoundOnCooldown = true;
          } else {
              isReceiveSoundOnCooldown = true;
          }

          const audio = new Audio(src);
          audio.preload = 'auto'; // Load sound data

          // Adjust volume: reduce send sound by 50% (total reduction: 30% + 20%)
          if (isSend) {
              audio.volume = 0.5; // 1.0 (full volume) - 0.5 (50% reduction) = 0.5
          } else {
              audio.volume = 1.0; // Keep receive sound at full volume
          }

          audio.play().catch(e => console.error(`Error playing ${isSend ? 'send' : 'receive'} sound:`, e));

          // Set a cooldown period
          setTimeout(() => {
              if (isSend) {
                  isSendSoundOnCooldown = false;
              } else {
                  isReceiveSoundOnCooldown = false;
              }
              // Optional: You can nullify the audio object to hint for garbage collection,
              // though modern browsers are usually good at cleaning up short-lived audio.
              // audio = null;
          }, 500); // 500ms cooldown
      }

      // Load background from local storage for the chat messages area
      const savedChatBgImage = localStorage.getItem('chatMessagesBackgroundImage');
      if (savedChatBgImage) {
        chatMessages.style.backgroundImage = `url('${savedChatBgImage}')`;
        chatMessages.style.backgroundSize = 'cover';
        chatMessages.style.backgroundPosition = 'center';
        chatMessages.style.backgroundRepeat = 'no-repeat';
      } else {
        chatMessages.style.backgroundImage = 'none';
      }

      const keywordReplies = {
        '‡∏Ñ‡∏¥‡∏î‡∏ñ‡∏∂‡∏á': '‡∏Ñ‡∏¥‡∏î‡∏ñ‡∏∂‡∏á‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô‡∏Ñ‡πâ‡∏≤‡∏ö ü•∞',
        '‡πÄ‡∏´‡∏ô‡∏∑‡πà‡∏≠‡∏¢': '‡πÇ‡∏≠‡πã‡πÜ ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏£‡∏ô‡∏∞‡∏Ñ‡∏ô‡πÄ‡∏Å‡πà‡∏á ‡∏Å‡∏≠‡∏î‡πÜ ‡∏ô‡∏∞‡∏Ñ‡∏∞ ',
        '‡∏£‡∏±‡∏Å': '‡∏£‡∏±‡∏Å‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏≠‡∏µ‡∏Å! üíñ',
        '‡∏ù‡∏±‡∏ô‡∏î‡∏µ': '‡∏ù‡∏±‡∏ô‡∏î‡∏µ‡∏Ñ‡πà‡∏≤‡∏≤‡∏≤ ‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏ù‡∏±‡∏ô‡∏ñ‡∏∂‡∏á‡πÄ‡∏Ñ‡πâ‡∏≤‡∏ô‡∏∞ üò¥',
        '‡∏ó‡∏≥‡πÑ‡∏£': '‡∏Ñ‡∏¥‡∏î‡∏ñ‡∏∂‡∏á‡πÄ‡∏ò‡∏≠‡∏≠‡∏¢‡∏π‡πà‡πÑ‡∏á‡∏Ñ‡πâ‡∏≤‡∏ö‡∏ö‡∏ö',
        '‡∏ö‡πâ‡∏≤': '‡∏ö‡πâ‡∏≤‡∏Å‡πá‡∏£‡∏±‡∏Å‡∏ô‡πâ‡∏≤‡∏≤‡∏≤‡∏≤~'
      };

      const voiceReplies = {
        '‡∏ö‡∏µ‡πã': 'audio/babe.mp3',
        '‡∏´‡∏¥‡∏ß': 'audio/hungry.mp3',
        '‡∏Å‡∏≠‡∏î': 'audio/hug.mp3'
      };

      const imageReplies = [
        'images/1.jpg',
        'images/2.jpg',
        'images/3.jpg',
        'images/4.jpg',
      ];

      // Array for food images
      const foodImageReplies = [
          'images/food1.jpg',
          'images/food2.jpg',
          'images/food3.jpg',
          'images/food4.jpg',
          'images/food5.jpg'
      ];

      // Array for Mon/Face images
      const monFaceImageReplies = [
          'images/mon1.jpg',
          'images/mon2.jpg',
          'images/mon3.jpg',
          'images/mon4.jpg',
          'images/mon5.jpg'
          
      ];


      const autoReplies = [
        "‡∏™‡∏π‡πâ‡πÜ ‡∏ô‡∏∞‡∏Ñ‡∏∞‡∏Ñ‡∏ô‡πÄ‡∏Å‡πà‡∏á ‚úåÔ∏è",
        "‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏á‡∏ö‡πâ‡∏≤‡∏á‡∏Ñ‡∏∞?",
        "‡∏°‡∏µ‡∏≠‡∏∞‡πÑ‡∏£‡πÉ‡∏´‡πâ‡∏ä‡πà‡∏ß‡∏¢‡∏°‡∏±‡πâ‡∏¢‡∏Ñ‡∏∞?",
        "‡∏ó‡∏≤‡∏ô‡∏Ç‡πâ‡∏≤‡∏ß‡∏£‡∏∂‡∏¢‡∏±‡∏á‡∏Ñ‡πâ‡∏≤‡∏ö üçö",
        "‡πÄ‡∏Å‡πà‡∏á‡∏°‡∏≤‡∏Å‡πÜ ‡πÄ‡∏•‡∏¢‡∏Ñ‡πà‡∏∞‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ üëç",
        "‡∏û‡∏±‡∏Å‡∏ú‡πà‡∏≠‡∏ô‡πÄ‡∏¢‡∏≠‡∏∞‡πÜ ‡∏ô‡πâ‡∏≤‡∏≤‡∏≤",
        "‡∏™‡πà‡∏á‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏à‡πÉ‡∏´‡πâ‡∏£‡∏±‡∏ß‡πÜ ‡πÄ‡∏•‡∏¢‡∏¢‡∏¢ üíï",
        "‡∏ß‡πà‡∏≤‡πÑ‡∏á‡∏Ñ‡∏∞‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏Å"
      ];

      function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
      }

      // Modified addMessage to handle scrolling based on message type and enforce image size
      function addMessage(content, sender, type = 'text', messageId = null) {
        const messageWrapper = document.createElement('div');
        if (messageId) { // Apply ID if provided
            messageWrapper.id = messageId;
        }
        messageWrapper.className = `flex items-end gap-2 ${sender === 'user' ? 'justify-end' : 'justify-start'}`;

        const messageBubble = document.createElement('div');
        messageBubble.classList.add('rounded-2xl', 'shadow');

        let shouldScrollImmediately = true; // Default for text/audio

        if (sender === 'user') {
          if (type === 'image') {
            // Apply specific classes for user image bubble: smaller width, padding
            messageBubble.classList.add('bg-blue-500', 'p-1', 'w-48'); // Set bubble width to w-48 (192px)
            const imgElement = document.createElement('img');
            imgElement.src = content;
            imgElement.alt = 'User sent image';
            // Image should fill its parent bubble
            imgElement.classList.add('w-full', 'h-auto', 'rounded-lg', 'object-cover');
            messageBubble.appendChild(imgElement);
            shouldScrollImmediately = false; // Wait for image to load

            imgElement.onload = () => {
                scrollToBottom();
            };
            imgElement.onerror = () => {
                console.error('Failed to load user image:', content);
                // Fallback if image fails to load: remove image classes, add text classes
                messageBubble.classList.remove('p-1', 'bg-blue-500', 'w-48');
                messageBubble.classList.add('p-3', 'bg-red-200', 'text-red-800', 'max-w-xs');
                messageBubble.textContent = `‡∏™‡πà‡∏á‡∏£‡∏π‡∏õ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ (‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏û‡∏ö: ${content.split('/').pop()})`;
                scrollToBottom(); // Scroll even if failed
            };

          } else { // User text message
            messageBubble.classList.add('bg-blue-500', 'text-white', 'p-3', 'max-w-xs', 'md:max-w-sm');
            messageBubble.textContent = content;
          }
          messageWrapper.appendChild(messageBubble);

        } else { // Bot messages (text, audio, or image)
          const botAvatar = document.createElement('img');
          botAvatar.src = 'bot-avatar.jpg';
          botAvatar.alt = 'Bot Avatar';
          botAvatar.className = 'w-8 h-8 rounded-full object-cover flex-shrink-0';

          if (type === 'audio') {
            messageBubble.classList.add('voice-message-player');
            const audioPlayer = document.createElement('audio');
            audioPlayer.src = content;
            audioPlayer.preload = 'metadata';

            const playButton = document.createElement('button');
            playButton.innerHTML = `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>`;

            const progressBar = document.createElement('progress');
            progressBar.value = 0;
            progressBar.max = 1;

            const timeDisplay = document.createElement('span');
            timeDisplay.className = 'time-display';
            timeDisplay.textContent = '0:00';

            messageBubble.appendChild(playButton);
            messageBubble.appendChild(progressBar);
            messageBubble.appendChild(timeDisplay);
            messageBubble.appendChild(audioPlayer);

            playButton.addEventListener('click', () => {
              if (audioPlayer.paused) { audioPlayer.play(); playButton.innerHTML = `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`; }
              else { audioPlayer.pause(); playButton.innerHTML = `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>`; }
            });

            audioPlayer.addEventListener('timeupdate', () => { progressBar.value = audioPlayer.currentTime; timeDisplay.textContent = formatTime(audioPlayer.currentTime); });
            audioPlayer.addEventListener('loadedmetadata', () => { progressBar.max = audioPlayer.duration; timeDisplay.textContent = formatTime(audioPlayer.duration); });
            audioPlayer.addEventListener('ended', () => { playButton.innerHTML = `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>`; progressBar.value = 0; timeDisplay.textContent = formatTime(audioPlayer.duration); });

          } else if (type === 'image') { // Bot image message
            // Apply specific classes for bot image bubble: smaller width, padding
            messageBubble.classList.add('bg-gray-200', 'p-1', 'w-48'); // Set bubble width to w-48 (192px)
            const imgElement = document.createElement('img');
            imgElement.src = content;
            imgElement.alt = 'Bot sent image';
            // Image should fill its parent bubble
            imgElement.classList.add('w-full', 'h-auto', 'rounded-lg', 'object-cover');
            messageBubble.appendChild(imgElement);
            shouldScrollImmediately = false;

            imgElement.onload = () => {
                scrollToBottom();
            };
            imgElement.onerror = () => {
                console.error('Failed to load bot image:', content);
                // Fallback if image fails to load: remove image classes, add text classes
                messageBubble.classList.remove('p-1', 'bg-gray-200', 'w-48');
                messageBubble.classList.add('p-3', 'bg-red-200', 'text-red-800', 'max-w-xs');
                messageBubble.textContent = `‡∏ö‡∏≠‡∏ó‡∏™‡πà‡∏á‡∏£‡∏π‡∏õ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ (‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡∏û‡∏ö: ${content.split('/').pop()})`;
                scrollToBottom(); // Scroll even if failed
            };

          } else { // Bot text message
            messageBubble.classList.add('bg-gray-200', 'text-gray-800', 'p-3', 'max-w-xs', 'md:max-w-sm');
            messageBubble.textContent = content;
          }

          messageWrapper.appendChild(botAvatar);
          messageWrapper.appendChild(messageBubble);
        }

        chatMessages.appendChild(messageWrapper);
        if (shouldScrollImmediately) {
            scrollToBottom();
        }

        // Play receive sound if it's a bot message
        if (sender === 'bot') { // Only play if it's a bot message
            playSoundEffect('sounds/receive.mp3', false); // Play receive sound at normal volume
        }
      }

      function scrollToBottom() {
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      function handleSendMessage() {
        const text = messageInput.value.trim();
        if (text === '') return;

        addMessage(text, 'user');
        messageInput.value = '';

        // Play send sound when user sends a message
        playSoundEffect('sounds/send.mp3', true); // Play send sound with reduced volume

        // Add a temporary "typing..." message bubble
        const typingBubbleId = 'bot-typing-indicator';
        addMessage('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏¥‡∏°‡∏û‡πå...', 'bot', 'text', typingBubbleId);
        const tempTypingBubbleElement = document.getElementById(typingBubbleId);
        if (tempTypingBubbleElement) {
            // Target the actual message bubble div for styling
            const textBubbleDiv = tempTypingBubbleElement.querySelector('div.bg-gray-200');
            if (textBubbleDiv) {
                textBubbleDiv.classList.add('opacity-70', 'animate-pulse');
            }
        }

        setTimeout(() => sendBotReply(text, typingBubbleId), 1000 + Math.random() * 500);
      }

      function sendBotReply(userMessage, typingBubbleId) {
        // Remove the typing indicator message before adding the actual reply
        const tempTypingBubble = document.getElementById(typingBubbleId);
        if (tempTypingBubble) {
            tempTypingBubble.remove();
        }

        let replyContent = null;
        let replyType = 'text';

        const lowerCaseMessage = userMessage.toLowerCase();

        if (lowerCaseMessage.includes('‡∏™‡πà‡∏á‡∏£‡∏π‡∏õ') || lowerCaseMessage.includes('‡∏™‡πà‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û')) {
            const randomIndex = Math.floor(Math.random() * imageReplies.length);
            replyContent = imageReplies[randomIndex];
            replyType = 'image';
            console.log(`‡∏ö‡∏≠‡∏ó‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û: ${replyContent}`);
        } else if (lowerCaseMessage.includes('‡∏Å‡∏¥‡∏ô')) {
            const randomIndex = Math.floor(Math.random() * foodImageReplies.length);
            replyContent = foodImageReplies[randomIndex];
            replyType = 'image';
            console.log(`‡∏ö‡∏≠‡∏ó‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡∏≠‡∏≤‡∏´‡∏≤‡∏£: ${replyContent}`);
        } else if (lowerCaseMessage.includes('‡∏´‡∏ô‡πâ‡∏≤') || lowerCaseMessage.includes('‡∏°‡πà‡∏≠‡∏ô')) {
            const randomIndex = Math.floor(Math.random() * monFaceImageReplies.length);
            replyContent = monFaceImageReplies[randomIndex];
            replyType = 'image';
            console.log(`‡∏ö‡∏≠‡∏ó‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡∏´‡∏ô‡πâ‡∏≤/‡∏°‡πà‡∏≠‡∏ô: ${replyContent}`);
        } else {
            for (const keyword in voiceReplies) {
              if (lowerCaseMessage.includes(keyword)) {
                replyContent = voiceReplies[keyword];
                replyType = 'audio';
                console.log(`‡∏ö‡∏≠‡∏ó‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á: ${replyContent}`);
                break;
              }
            }
            if (!replyContent) {
              for (const keyword in keywordReplies) {
                if (lowerCaseMessage.includes(keyword)) {
                  replyContent = keywordReplies[keyword];
                  replyType = 'text';
                  console.log(`‡∏ö‡∏≠‡∏ó‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°: ${replyContent}`);
                  break;
                }
              }
            }
            if (!replyContent) {
              const randomIndex = Math.floor(Math.random() * autoReplies.length);
              replyContent = autoReplies[randomIndex];
              replyType = 'text';
              console.log(`‡∏ö‡∏≠‡∏ó‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥: ${replyContent}`);
            }
        }

        addMessage(replyContent, 'bot', replyType);
      }

      // Event listener for background upload (existing)
      uploadBgInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            const imageUrl = e.target.result;
            chatMessages.style.backgroundImage = `url('${imageUrl}')`;
            chatMessages.style.backgroundSize = 'cover';
            chatMessages.style.backgroundPosition = 'center';
            chatMessages.style.backgroundRepeat = 'no-repeat';
            localStorage.setItem('chatMessagesBackgroundImage', imageUrl);
          };
          reader.readAsDataURL(file);
        }
      });

      // Modified: Event listener for user image upload to add typing indicator
      uploadImageInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            const imageUrl = e.target.result;
            addMessage(imageUrl, 'user', 'image'); // Add user image to chat

            // Play send sound when user sends an image
            playSoundEffect('sounds/send.mp3', true); // Play send sound with reduced volume

            // Add a temporary "typing..." message bubble before bot reply
            const typingBubbleId = 'bot-typing-indicator-image-reply';
            addMessage('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏¥‡∏°‡∏û‡πå...', 'bot', 'text', typingBubbleId);
            const tempTypingBubbleElement = document.getElementById(typingBubbleId);
            if (tempTypingBubbleElement) {
                const textBubbleDiv = tempTypingBubbleElement.querySelector('div.bg-gray-200');
                if (textBubbleDiv) {
                    textBubbleDiv.classList.add('opacity-70', 'animate-pulse');
                }
            }

            setTimeout(() => sendBotReply("‡∏™‡πà‡∏á‡∏£‡∏π‡∏õ", typingBubbleId), 1000 + Math.random() * 500);
          };
          reader.readAsDataURL(file);
        }
      });


      sendButton.addEventListener('click', handleSendMessage);
      messageInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') handleSendMessage();
      });

      // Removed the initial setTimeout that adds a bot message without user interaction
      // setTimeout(() => {
      //   addMessage('‡∏Ñ‡∏¥‡∏î‡∏ñ‡∏∂‡∏á‡πÄ‡∏Ñ‡πâ‡∏≤‡∏´‡∏£‡∏≠‡∏Ñ‡∏∞‡∏ö‡∏µ‡πã', 'bot');
      // }, 500);
    });
  </script>
</body>
</html>
