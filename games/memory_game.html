<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡πÄ‡∏Å‡∏°‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏†‡∏≤‡∏û - ‡πÄ‡∏Å‡∏°‡∏Ç‡∏≠‡∏á‡∏°‡πà‡∏≠‡∏ô</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Kanit', sans-serif;
            background-color: #f0f9ff;
            background-image: radial-gradient(#bae6fd 1px, transparent 1px);
            background-size: 20px 20px;
            color: #374151;
            overflow: hidden;
        }
        .app-container {
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            box-shadow: 0 0 50px rgba(56, 189, 248, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        .memory-grid {
            display: grid;
            gap: 8px;
            margin: 0 auto;
            padding: 8px;
            background-color: #374151;
            border-radius: 1rem;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        .grid-2x3 { grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(3, 1fr); width: 220px; }
        .grid-2x4 { grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(4, 1fr); width: 220px; }
        .grid-3x4 { grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(4, 1fr); width: 330px; }
        .grid-4x4 { grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(4, 1fr); width: 440px; }
        .memory-card {
            background-color: #4b5563;
            border-radius: 0.5rem;
            cursor: pointer;
            aspect-ratio: 1 / 1;
            transform-style: preserve-3d;
            transition: transform 0.6s, box-shadow 0.3s;
            transform: rotateY(0deg);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .memory-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 15px rgba(0,0,0,0.4);
        }
        .memory-card.flipped {
            transform: rotateY(180deg);
            pointer-events: none;
        }
        .memory-card .front, .memory-card .back {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
            backface-visibility: hidden;
            overflow: hidden;
        }
        .memory-card .front {
            background-image: linear-gradient(145deg, #60a5fa, #3b82f6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            color: white;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.5);
        }
        .memory-card .back {
            transform: rotateY(180deg);
            background-color: #ffffff;
            border: 2px solid #3b82f6;
        }
        .memory-card .back img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .memory-card.matched {
            transform: scale(0.9);
            opacity: 0;
            pointer-events: none;
            transition: transform 0.4s, opacity 0.4s;
        }
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex; justify-content: center; align-items: center;
            z-index: 1000; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease;
        }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-content {
            background: white; padding: 2rem; border-radius: 1.5rem;
            text-align: center; width: 90%; max-width: 380px;
            transform: scale(0.9) translateY(20px); transition: transform 0.3s ease;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .modal-overlay.visible .modal-content { transform: scale(1) translateY(0); }
        .modal-title {
            font-size: 2rem; font-weight: 700;
            background: linear-gradient(135deg, #60a5fa, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">

    <div id="app-container" class="app-container max-w-lg mx-auto p-4 rounded-3xl">
        <div id="memory-game-screen">
            <header class="flex items-center justify-between mb-4">
                <a href="index.html" class="text-3xl text-sky-500 hover:text-sky-600 transition">&larr;</a>
                <h1 class="text-4xl font-bold bg-gradient-to-r from-sky-500 to-indigo-500 text-transparent bg-clip-text">‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏†‡∏≤‡∏û!</h1>
                <div></div>
            </header>
            
            <div class="grid grid-cols-3 gap-2 text-center mb-4 p-3 bg-white rounded-2xl shadow-inner">
                <div>
                    <p class="text-sm text-gray-500">LEVEL</p>
                    <p id="memory-level" class="font-bold text-2xl text-purple-500">1</p>
                </div>
                <div>
                    <p class="text-sm text-gray-500">‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏û‡∏•‡∏≤‡∏î</p>
                    <p id="memory-chances" class="font-bold text-2xl text-red-500">‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è</p>
                </div>
                <div>
                    <p class="text-sm text-gray-500">‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏™‡∏∞‡∏™‡∏°</p>
                    <p id="memory-reward" class="font-bold text-2xl text-amber-500">0</p>
                </div>
            </div>
            
            <p id="memory-peek-timer" class="text-center mt-1 text-lg h-8 font-semibold text-gray-600"></p>

            <div id="memory-grid-container" class="flex justify-center items-center">
                <div id="memory-grid"></div>
            </div>
        </div>
    </div>
    
    <div id="level-clear-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="modal-title mb-2">‡∏ú‡πà‡∏≤‡∏ô‡∏î‡πà‡∏≤‡∏ô!</h2>
            <p class="text-5xl mb-4">üéâ</p>
            <p class="text-gray-600 text-lg mb-1">‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö <span id="level-reward-text" class="font-bold text-amber-500"></span> ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏°‡πà‡∏≠‡∏ô!</p>
            <p id="bonus-game-text-win" class="text-green-500 font-bold mb-4 hidden">(x2 ‡∏à‡∏≤‡∏Å‡πÄ‡∏Å‡∏°‡πÇ‡∏ö‡∏ô‡∏±‡∏™!)</p>
            <button id="next-level-btn" class="w-full mt-4 px-4 py-3 text-lg font-bold text-white rounded-xl shadow-md bg-gradient-to-br from-sky-500 to-blue-600">‡∏î‡πà‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡πÑ‡∏õ</button>
        </div>
    </div>
    
    <div id="game-over-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="modal-title mb-2">‡πÄ‡∏Å‡∏°‡∏à‡∏ö‡πÅ‡∏•‡πâ‡∏ß!</h2>
            <p class="text-5xl mb-4">üò≠</p>
            <p class="text-gray-600 text-lg mb-4">‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î <span id="total-reward-text" class="font-bold text-amber-500"></span> ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏°‡πà‡∏≠‡∏ô!</p>
             <p id="bonus-game-text-lose" class="text-green-500 font-bold mb-4 hidden">‡πÄ‡∏Å‡∏°‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏Å‡∏°‡πÇ‡∏ö‡∏ô‡∏±‡∏™ ‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ñ‡∏π‡∏Å‡∏Ñ‡∏π‡∏ì 2 ‡πÅ‡∏•‡πâ‡∏ß!</p>
            <a href="index.html" class="block w-full mt-4 px-4 py-3 text-lg font-bold text-white rounded-xl shadow-md bg-gradient-to-br from-pink-500 to-rose-500">‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏π‡πà‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å</a>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let state = {};
            // DOM Elements...
            const memoryLevelDisplay = document.getElementById('memory-level');
            const memoryChancesDisplay = document.getElementById('memory-chances');
            const memoryRewardDisplay = document.getElementById('memory-reward');
            const memoryPeekTimerDisplay = document.getElementById('memory-peek-timer');
            const memoryGrid = document.getElementById('memory-grid');
            const levelClearModal = document.getElementById('level-clear-modal');
            const gameOverModal = document.getElementById('game-over-modal');
            const nextLevelBtn = document.getElementById('next-level-btn');
            const levelRewardText = document.getElementById('level-reward-text');
            const totalRewardText = document.getElementById('total-reward-text');
            const bonusWinText = document.getElementById('bonus-game-text-win');
            const bonusLoseText = document.getElementById('bonus-game-text-lose');

            let isCurrentGameBonus = false;

            // --- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ã‡∏ü‡∏â‡∏ö‡∏±‡∏ö‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå ---
            function saveState() {
                localStorage.setItem('monGameDataV17', JSON.stringify(state));
            }

            function loadState() {
                const savedData = localStorage.getItem('monGameDataV17');
                if (savedData) {
                    try {
                        state = JSON.parse(savedData);
                        // Migration checks...
                        if (!state.pet) state.pet = { exists: false };
                    } catch (e) {
                        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ã‡∏ü!');
                        window.location.href = 'index.html';
                    }
                } else {
                    alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô! ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å...');
                    window.location.href = 'index.html';
                }
            }
            
            const allImages = ['1.jpg', '2.jpg', '3.jpg', '4.jpg', '5.jpg', '6.jpg', '7.jpg', '8.jpg'];
            let memoryGameState = {};

            function initializeMemoryGame() {
                loadState();
                const urlParams = new URLSearchParams(window.location.search);
                isCurrentGameBonus = urlParams.get('bonus') === 'true';

                // --- ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÑ‡∏õ‡πÉ‡∏ä‡πâ "‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡πÄ‡∏•‡πà‡∏ô‡∏°‡πà‡∏≠‡∏ô" (playCoins) ---
                const gameCost = 1;
                if (state.playCoins >= gameCost) {
                    state.playCoins -= gameCost; // << ‡∏´‡∏±‡∏Å‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡πÄ‡∏•‡πà‡∏ô‡∏°‡πà‡∏≠‡∏ô
                    saveState();

                    memoryGameState = {
                        level: 1,
                        totalReward: 0,
                        chances: 5,
                        cards: [],
                        flippedCards: [],
                        matchedPairs: 0,
                        canFlip: false,
                    };
                    startMemoryLevel();
                } else {
                    alert('‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡πÄ‡∏•‡πà‡∏ô‡∏°‡πà‡∏≠‡∏ô‡πÑ‡∏°‡πà‡∏û‡∏≠! ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ 1 ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡πÄ‡∏•‡πà‡∏ô‡∏°‡πà‡∏≠‡∏ô‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô');
                    window.location.href = 'index.html';
                }
            }

            // ... (‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏° ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á) ...

            function updateStatusDisplay() {
                memoryLevelDisplay.textContent = memoryGameState.level;
                memoryRewardDisplay.textContent = memoryGameState.totalReward;
                memoryChancesDisplay.textContent = '‚ù§Ô∏è '.repeat(memoryGameState.chances).trim();
            }

            function startMemoryLevel() {
                memoryGameState.flippedCards = [];
                memoryGameState.matchedPairs = 0;
                updateStatusDisplay();
                const levelConfig = getLevelConfig(memoryGameState.level);
                createMemoryBoard(levelConfig);
                let countdown = levelConfig.peekTime;
                memoryPeekTimerDisplay.textContent = `‡∏à‡∏≥‡∏†‡∏≤‡∏û‡πÉ‡∏ô ${countdown} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ...`;
                const peekInterval = setInterval(() => {
                    countdown--;
                    memoryPeekTimerDisplay.textContent = `‡∏à‡∏≥‡∏†‡∏≤‡∏û‡πÉ‡∏ô ${countdown} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ...`;
                    if (countdown <= 0) {
                        clearInterval(peekInterval);
                        memoryPeekTimerDisplay.textContent = '‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡πÑ‡∏î‡πâ!';
                        memoryGameState.cards.forEach(card => card.classList.remove('flipped'));
                        memoryGameState.canFlip = true;
                    }
                }, 1000);
            }

            function getLevelConfig(level) {
                if (level === 1) return { pairs: 3, gridClass: 'grid-2x3', peekTime: 3 };
                if (level <= 3) return { pairs: 4, gridClass: 'grid-2x4', peekTime: 4 };
                if (level <= 5) return { pairs: 6, gridClass: 'grid-3x4', peekTime: 5 };
                return { pairs: 8, gridClass: 'grid-4x4', peekTime: 6 };
            }

            function createMemoryBoard(config) {
                const neededImages = allImages.slice(0, config.pairs);
                const cardImages = [...neededImages, ...neededImages].sort(() => 0.5 - Math.random());
                memoryGrid.className = `memory-grid ${config.gridClass}`;
                memoryGrid.innerHTML = '';
                memoryGameState.cards = [];
                memoryGameState.totalPairs = config.pairs;
                cardImages.forEach(imageSrc => {
                    const card = document.createElement('div');
                    card.className = 'memory-card flipped';
                    card.dataset.image = imageSrc;
                    card.innerHTML = `<div class="front">?</div><div class="back"><img src="${imageSrc}" alt="card"></div>`;
                    card.addEventListener('click', () => handleCardClick(card));
                    memoryGrid.appendChild(card);
                    memoryGameState.cards.push(card);
                });
            }

            function handleCardClick(clickedCard) {
                if (!memoryGameState.canFlip || clickedCard.classList.contains('flipped')) return;
                clickedCard.classList.add('flipped');
                memoryGameState.flippedCards.push(clickedCard);
                if (memoryGameState.flippedCards.length === 2) {
                    memoryGameState.canFlip = false;
                    checkForMatch();
                }
            }

            function checkForMatch() {
                const [cardOne, cardTwo] = memoryGameState.flippedCards;
                if (cardOne.dataset.image === cardTwo.dataset.image) {
                    cardOne.classList.add('matched');
                    cardTwo.classList.add('matched');
                    memoryGameState.matchedPairs++;
                    memoryGameState.flippedCards = [];
                    setTimeout(() => {
                        memoryGameState.canFlip = true;
                        if (memoryGameState.matchedPairs === memoryGameState.totalPairs) {
                            handleLevelWin();
                        }
                    }, 500);
                } else {
                    memoryGameState.chances--;
                    updateStatusDisplay();
                    setTimeout(() => {
                        cardOne.classList.remove('flipped');
                        cardTwo.classList.remove('flipped');
                        memoryGameState.flippedCards = [];
                        if (memoryGameState.chances <= 0) {
                            handleGameOver();
                        } else {
                            memoryGameState.canFlip = true;
                        }
                    }, 1000);
                }
            }

            function handleLevelWin() {
                let baseReward = (memoryGameState.level * 2) + memoryGameState.totalPairs;
                let reward = Math.floor(baseReward / 2);
                bonusWinText.classList.add('hidden');
                if (isCurrentGameBonus) {
                    reward *= 2;
                    bonusWinText.classList.remove('hidden');
                }
                state.monCoins += reward;
                memoryGameState.totalReward += reward;
                saveState();
                levelRewardText.textContent = reward;
                levelClearModal.classList.add('visible');
            }

            function handleGameOver() {
                totalRewardText.textContent = memoryGameState.totalReward;
                bonusLoseText.classList.add('hidden');
                if (isCurrentGameBonus) {
                    bonusLoseText.classList.remove('hidden');
                }
                gameOverModal.classList.add('visible');
            }

            nextLevelBtn.addEventListener('click', () => {
                memoryGameState.level++;
                levelClearModal.classList.remove('visible');
                startMemoryLevel();
            });

            initializeMemoryGame();
        });
    </script>
</body>
</html>
